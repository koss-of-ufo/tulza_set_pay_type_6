js/main.js

Роль: точка входа (bootstrap) для bulk sender’а.
Что делает:

получает DOM через getDom();

инициализирует URL по выбранному mode;

навешивает обработчики UI (bindUiHandlers);

навешивает обработчики событий от парсера (через bindWindowEvents);

включает сохранение токена (initTokenPersistence);

выставляет нулевые счётчики;

пишет стартовый лог.

Зависимости: dom.js, state.js, ui.js, handlers.js.

js/state.js

Роль: единое хранилище состояния отправки.
Зачем нужно: чтобы не держать глобальные переменные в разных местах и не размазывать let по файлу.

Хранит:

parsedRows — список строк для отправки (uuid + возможно pan);

errors — список ошибок;

report — итоговый отчёт по каждой записи;

running — флаг “идёт отправка”;

abortController — чтобы уметь отменять fetch;

paused — ручная пауза.

js/dom.js

Роль: централизованно собрать все элементы интерфейса bulk sender’а.
Что экспортирует: getDom() возвращает объект со всеми DOM-ссылками.

Зачем нужно:

меньше повторов document.getElementById;

проще рефакторить (переименовал id — поправил в одном месте).

js/utils.js

Роль: утилиты без привязки к DOM.
Содержит:

uuidRegex — регулярка UUID;

sleep, waitWhilePaused — задержки и уважение паузы;

detectSeparator — угадывание разделителя CSV/табличных строк;

extractUUIDsFromString — быстро вытаскивает UUID’ы из любого текста;

cyrToLatPan — перевод кириллицы в латиницу для PAN.

Почему отдельно: эти вещи проще тестировать/переиспользовать.

js/parsers.js

Роль: парсинг входных данных из файла/textarea.
Содержит:

parsePanText(text) — режим “пан-замена”: привязка UUID’ов к последнему найденному PAN в тексте;

parseCSVTextGeneric(text, ...) — универсальный парсер “CSV/таблица/список”, с попыткой понять, есть ли header.

Важно: этот слой ничего не знает про fetch, кнопки, UI — только преобразует текст → массив строк.

js/api.js

Роль: изолировать сетевой вызов.
Экспорт: doFetch(dom, state, payload)
Что делает:

берёт endpoint, method, token из UI;

делает fetch с AbortController;

пытается распарсить JSON, иначе text;

возвращает {ok,status,body}.

Зачем отдельно: чтобы отправка и UI не знали детали “как fetch устроен”.

js/ui.js

Роль: только UI-операции bulk sender’а.
Содержит:

appendLog(dom, ...) — лог в “консоль” интерфейса;

setCounters(dom, state) — обновление счётчиков total/success/fail/progress;

updateUrlByMode(dom) — меняет URL при переключении режима.

js/handlers.js

Роль: “склейка” всего поведения bulk sender’а.
Здесь живут высокоуровневые сценарии:

parseSource(dom, state) — читает file/textarea, выбирает правильный парсер, чистит результаты, пишет лог, сбрасывает отчёты;

buildPayloadForRow(dom, row) — строит payload в зависимости от mode;

bindUiHandlers(...) — навешивает кнопки Preview/SendOne/SendAll/Stop/Download;

downloadErrors, downloadReport — выгрузка CSV;

bindWindowEvents — слушает parsed-uuids-ready и parsed-grn-mode-ready от парсера (связка “парсер → сендер”);

initTokenPersistence — localStorage для токена (и автодобавление Bearer).

Почему это отдельный файл: это “контроллер”, который orchestrates всё.